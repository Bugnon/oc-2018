<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="12279" name="thymio-II">#Thymio Tokyo watch structure commune groupe 1
#Hélène Hugo Pierre Térence
#2018.09.20

####################
#                  #
# Module principal #
#                  #
####################

var display_h #Affichage heures
var display_m #Affichage minutes
var display_s #Affichage secondes

var display_am # AM?

var time

var mode
# 0 : clock
# 1 : alarm
# 2 : chronometer
# 3 : timer

var active #mode actif?

var couleur1[4] #tableau R des modules
var couleur2[4] #tableau G des modules
var couleur3[4] #tableau B des modules

var test #variable de test

#Variables modules

var clock_h
var clock_m
var clock_s

#Tableau de couleurs des modules

couleur1 = [16,32,0,32]
couleur2 = [0,16,0,32]
couleur3 = [16,0,0,0]

#Timer temporaire, à déplacer dans le module horloge
timer.period[0] = 10 #1000ms=1s | mis sur 0.001s pour les tests

display_am = 1 #commence en tant que AM

#Gestion des modules
onevent buttons
	when button.left==1 do #décrémente le mode de 1 à chaque pression
		mode --
		active=0 #marque la sélection comme non active à chaque changement de mode
		if mode&lt;0 then #saute à 3 si minimum atteint
			mode=3
		end
	end
	
	when button.right==1 do #pareil mais dans le sens inverse
		mode ++
		active=0
		if mode>3 then
			mode=0
		end
	end

	when button.center==1 do #active la sélection
		active=1
	end

#Gestion de l'affichage
onevent acc #activation 16Hz
	#affiche les secondes en binaire sur les capteurs frontaux
	call leds.prox.h((display_s&amp;1)*32,(display_s&amp;2)*16,(display_s&amp;4)*8,(display_s&amp;8)*4,(display_s&amp;16)*2,(display_s&amp;32)*1,0,0)
	#affiche les minutes en binaire sur le cercle
	call leds.circle((display_m&amp;1)*32,(display_m&amp;2)*16,(display_m&amp;4)*8,(display_m&amp;8)*4,(display_m&amp;16)*2,(display_m&amp;32)*1,0,0)
	#affiche les heures en binaire sur les boutons
	call leds.buttons((display_h&amp;1)*32,(display_h&amp;2)*16,(display_h&amp;4)*8,(display_h&amp;8)*4)

	#allume le coté gauche si AM==1
	call leds.bottom.left(display_am*32,display_am*32,display_am*0)
	#allume le coté droit si AM==0
	#~display_am retourne -1 si AM==0 -> +2 permet d'obtenir 1, *32 donne 32 si AM==1
	call leds.bottom.right(((~display_am)+2)*32,((~display_am)+2)*32,((~display_am)+2)*0)
	
	#affiche la fonction à intensité/2 si non activée, ou à intensité normale si activée. ~active+3 == 2 si active==0, ~active+3 == 1 si active==1
	call leds.top(couleur1[mode]/(~active+3),couleur2[mode]/(~active+3),couleur3[mode]/(~active+3))
	test = (~active+2)+1
	
	callsub clock
	
#################################
#                               #
# Fin du module principal       #
# Début des modules secondaires #
#                               #
#################################

###### Clock - Hélène ######
 
sub clock 
	onevent timer0
		if active==1 and mode==0 then 
			time++ #incrémente les secondes
			
			display_s = time%60
			display_m = (time/60)%60
			
			when time>=3600 do
				clock_h++
				time=0
			end
			
			when clock_h>=12 and display_am==0 do #passe AM en 1 après 12h s'il vaut 0
				display_am=1
				clock_h=0
			end

			when clock_h>=12 and display_am==1 do #passe AM en 0 après 12h s'il vaut 1
				display_am=0
				clock_h=0
			end
				
			display_h = clock_h
		end
		
###### Chrono ######

</node>


</network>
